✏️TIL
==

## 🤔재정리  
- protected가 붙으면 super가 없이 하위 클래스에서 호출이 가능하다
- 그 외에 상위 메소드의 것을 접근하려면 super를 사용  

<br>

- 접근 제어자  
- 
  | 접근자   | 클래스 내부 | 패키지 | 상속받은 클래스 | 이외의 영역 |
  |----------|------------|--------|------------------|-------------|
  | private  | O          | X      | X                | X           |
  | default  | O          | O      | X                | X           |
  | protected| O          | O      | O                | X           |
  | public   | O          | O      | O                | O           |

- /n vs %n 
  - printf ➡️ %n
  - println ➡️ /n  


- static 
  - 

<br>

## 🤓새로 알게 된 것

🪚 ___abstract___ 클래스
- 자식 클래스로 파생되기 위한 클래스
  - __관련된 여러 클래스들의 공통분모를 정의하기 위한 클래스__
- 그자체로 인스턴스 생성 불가
- 부모 클래스로서는 일반 클래스와 같다
  - 다형성 역시 가능
    - 다형성이란? 다형성이란 여러 개를 의미하는 poly와 형태 또는 실체를 의미하는 morphism의 결합어로, 하나의 객체가 여러 가지 형태를 가질 수 있는 것을 의미한다.  

🪚 ___abstract___ 메소드
- 추상 클래스에서만 사용가능
- 스스로는 선언만하고 구현하지는 않는다.
  - ⭐ __자식클래스에서 반드시 구현__
  - 구현하지 않을 시 컴파일 에러
    * 메뉴 - 코드 - 메서드 구현
  - 접근 제어자 의미 없음
- 클래스 메소드는 항상 추상 메소드로 작성 할 수 없음
  - 인스턴스를 생성해서 쓰는 것이 아니므로 맞지 않음  

<br>

🪚 __interface__  

| 개념                | 추상 클래스 | 인터페이스  |
|---------------------|-----|-------------|
| 물려 받는 것        | 혈통/가문/계열 | 장착하는 것 |
| 다중 적용            | 불가  | 가능  |
| 상속관계에 의한 제한 | 있음  | 없음        |
| 생성자              | 가짐  | 가지지 않음 |
| 메소드              | 구상, 추상 모두 가능 | 추상 메소드 (abstract 안 붙여도 됨), default 구상 메소드, 클래스 메소드 |
| 필드                | 모두 가능 | 상수만 가능 (final 명시 불필요) |
| 적용 연산자        | extends | implements  |

- 필드는 __public final static__
  - 명시할 필요는 없음 (무조건 final)
  - 초기화 필수 (무조건 final)
- 메소드는 __public abstract__
  - 명시할 필요는 없음 (무조건 final)
  - 메소드는 적용 클래스에서 구현 필수 (abstract와 같다)

- default 메소드
  - Java8에서 도입된 개념
    - 인터페이스에 새로운 메소드를 추가할 수 있게 함
    - 구현 클래스에서 선택적으로 구현 가능, 클래스에서 구현하지 않을시 인터페이스의 기본 구현 사용

- ```java
    public interface FoodSafety {
    static void announcement () {
        System.out.println("식품안전 관련 공지");
    } 
    // ↖️ 정적 메소드, 인터페이스 자체에 속함
    
    default void regularInspection () {
        System.out.println("정기 체크");
    } 
    // ↖️ 기본 메소드, 인터페이스 구현 클래스에서 선택적 구현 가능

    void cleanKitchen ();
    void employeeEducation ();
    // ↖️ 추상 메소드 , 인터페이스 구현 클래스는 반드시 구현 필요
  }
  ```
  
- ```java
  public class GlidingLizard extends Reptile implements Hunter, Swimmer, Flyer {
    // 이렇듯 인터페이스는 여러 개 구현 가능하지만 상속은 하나만 가능
  }
  ```
  

## 🐵 싱글톤(Singleton) 패턴
**객체의 인스턴스가 오직 1개만 생성**되는 패턴  

### 싱글톤 패턴을 사용하는 이유??
1. **메모리측면**  
   최초의 한번 new 연산자를 통해서 고정된 메모리 영역을 사용하기 때문에 추후 해당 객체에 접근할 때
   메모리 낭비를 방지할 수 있다.  


2. **데이터 공유가 쉽다**  
싱글톤 인스턴스가 전역으로 사용되는 인스턴스이기 때문에 다른 클래스의 인스턴스들이 접근하여 사용할 수 있다.


### 장점만 있을까? 단점은??
1. **코드 자체가 많이 필요하다(= 번거롭다?)**  
정적 팩토리 메서드에서 객체생성을 확인하고 생성자를 호출하는 경우를 예시로 들어보면, 멀티스레드 환경에서
발생할 수 있는 동시성 문제 때문에 **syncroized** 키워드를 사용해야한다.  


2. **테스트의 어려움**  
싱글톤 인스턴스는 자원을 공유하기 때문에 테스트가 결정적으로 격리된 환경에서 수행하려면 매번 인스턴스의 상태를 초기화 해줘야한다.
그렇지 않으면 어플리케이션 전역에서 상태를 공유하기 때문에 온전하게 수행되지 못한다. 


3. **의존 관계상 클라이턴트가 구체 클래스에 의존**  
new 키워드를 직접 사용하여 클래스안에 객체를 생성하고 있으므로 SOLID원칙 중 DIP를 위반하게 되고 OCP원칙 또한 위반할
가능성이 높다.  


__결론__:  
오직 한 개의 인스턴스 생성을 보증하여 효율을 찾을 수 있지만, 자식클래스를 만들수 없다는 점과, 내부 상태를 변경하기 어렵다는 점 등 여러가지 문제들이 존재한다.  
결과적으로 이러한 문제들을 안고있는 
싱글톤 패턴은 유연성이 많이 떨어지는 패턴이므로 ,
장단점의 trade-off를 잘 고려하여 사용하는 것이 좋을 것 같다.

⚙️ 용어 설명:  
   - DIP (Dependency Inversion Principle):
     - DIP는 의존성 역전 원칙으로, 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 양쪽 모듈 모두 추상화에 의존해야 한다는 원칙
     - 클라이언트 코드는 구체 클래스에 직접 의존하는 것이 아니라, 추상화된 인터페이스나 추상 클래스에 의존해야 한다. 
  
  
   - OCP (Open-Closed Principle):
     - OCP는 개체(클래스, 모듈, 함수 등)는 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다는 원칙
     - 기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있도록 설계해야 한다.



